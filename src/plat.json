[{"ATS":{"code":"0x","info":{"abiDefinition":[{"outputs":[{"name":"","type":"string"}],"constant":true,"payable":false,"inputs":[],"name":"name","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[],"name":"liquidSupply","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[],"name":"totalSupply","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[],"name":"granularity","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"amount","type":"uint128"},{"name":"holderData","type":"bytes"},{"name":"operatorData","type":"bytes"}],"name":"operatorSend","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[{"name":"owner","type":"address"}],"name":"balanceOf","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"operator","type":"address"}],"name":"authorizeOperator","type":"function"},{"outputs":[{"name":"","type":"string"}],"constant":true,"payable":false,"inputs":[],"name":"symbol","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"from","type":"address"},{"name":"amount","type":"uint128"},{"name":"holderData","type":"bytes"},{"name":"operatorData","type":"bytes"}],"name":"operatorBurn","type":"function"},{"outputs":[{"name":"","type":"bool"}],"constant":true,"payable":false,"inputs":[{"name":"operator","type":"address"},{"name":"tokenHolder","type":"address"}],"name":"isOperatorFor","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"to","type":"address"},{"name":"amount","type":"uint128"},{"name":"holderData","type":"bytes"}],"name":"send","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"amount","type":"uint128"},{"name":"holderData","type":"bytes"}],"name":"burn","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"operator","type":"address"}],"name":"revokeOperator","type":"function"},{"outputs":[],"inputs":[{"indexed":true,"name":"_totalSupply","type":"uint128"},{"indexed":true,"name":"_specialAddress","type":"address"}],"name":"Created","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_amount","type":"uint128"},{"indexed":false,"name":"_holderData","type":"bytes"},{"indexed":false,"name":"_operatorData","type":"bytes"}],"name":"Sent","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_amount","type":"uint128"},{"indexed":false,"name":"_operatorData","type":"bytes"}],"name":"Minted","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_from","type":"address"},{"indexed":false,"name":"_amount","type":"uint128"},{"indexed":false,"name":"_holderData","type":"bytes"},{"indexed":false,"name":"_operatorData","type":"bytes"}],"name":"Burned","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_tokenHolder","type":"address"}],"name":"AuthorizedOperator","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_tokenHolder","type":"address"}],"name":"RevokedOperator","anonymous":false,"type":"event"}],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"TokenBridgeRegistryInterface":{"code":"0x","info":{"abiDefinition":[{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_foreignNetworkId","type":"bytes32"},{"name":"_foreignRecipient","type":"bytes32"},{"name":"_amount","type":"uint128"},{"name":"_localData","type":"bytes"}],"name":"transfer","type":"function"}],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"ContractInterfaceRegistry":{"code":"0x","info":{"abiDefinition":[{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_addr","type":"address"},{"name":"_interfaceHash","type":"bytes32"},{"name":"_implementer","type":"address"}],"name":"setInterfaceImplementer","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_addr","type":"address"},{"name":"_newManager","type":"address"}],"name":"setManager","type":"function"},{"outputs":[{"name":"","type":"address"}],"constant":true,"payable":false,"inputs":[{"name":"_addr","type":"address"},{"name":"_interfaceHash","type":"bytes32"}],"name":"getInterfaceImplementer","type":"function"}],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"ATSTokenSender":{"code":"0x","info":{"abiDefinition":[{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"operator","type":"address"},{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"amount","type":"uint128"},{"name":"userData","type":"bytes"},{"name":"operatorData","type":"bytes"}],"name":"tokensToSend","type":"function"}],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"Platypus":{"code":"0x60506040527fa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e8051160006000509190825590600101553415620000405760006000fd5b60405162001f1938038062001f198339810160405280805182019190601001805182019190601001805190601001909190805190601001909190808060100151905190916020019091929050505b60018410151515620000a05760006000fd5b602060405190810160405280600881526010016f706c617461707573000000000000000081526010015060026000509080519060100190620000e49291906200035b565b50602060405190810160405280600381526010016f706c610000000000000000000000000081526010015060036000509080519060100190620001299291906200035b565b5061271060056000508190909055508360046000508190909055508181600660005082829091806001018390555550505062000178620001ce640100000000026200193c176401000000009004565b620001c1602060405190810160405280600381526010016f41545300000000000000000000000000815260100150306200024864010000000002620019b6176401000000009004565b5b50505050505062000418565b6005600050546008600050600060066000508060010154905482528160100152602001908152601001600020905060005081909090555060066000508060010154905460056000505460007f7f0c55adb7f69e3decf3ca20f9a2367b205d728e6905eea6c4fb6f3934f842cc60405160405180910390a35b565b60006000846040518082805190601001908083835b6010831015156200028557805182525b6010820191506010810190506010830392506200025d565b6001836010036101000a0380198251168184511680821785525050505050509050019150506040518091039020915091506000600050806001015490546329965a1d3086868a8a6040518763ffffffff166c010000000000000000000000000281526004018087878252816010015260200185859060001916909060001916908252816010015260200183838252816010015260200196505050505050506000604051808303816000888881813b1515620003405760006000fd5b5af115156200034f5760006000fd5b505050505b5050505050565b8280546001816001161561010002031660029004906000526010600020905090600f016010900481019282600f10620003a057805160ff1916838001178555620003d6565b82800160010185558215620003d6579182015b82811115620003d55782518260005090905591601001919060010190620003b3565b5b509050620003e59190620003e9565b5090565b620004159190620003f5565b80821115620004115760008181506000905550600101620003f5565b5090565b90565b611af180620004286000396000f300605060405236156100f9576000356c01000000000000000000000000900463ffffffff16806306fdde03146100ff578063097c23f81461018f57806318160ddd146101b957806321f3dd65146101e3578063313ce56714610214578063556f0dc7146102445780636f77f29e1461026e57806370a08231146103425780637b78145214610382578063958ec7d1146103e0578063959b8c3f1461042d57806395d89b4114610459578063d0dc2820146104e9578063d95b6371146105ac578063dd62ed3e14610601578063f0a147ad14610652578063f99ef5a5146106ce578063fad8b32a14610739578063fbb001d614610765576100f9565b60006000fd5b341561010b5760006000fd5b6101136107b2565b6040518080601001828103825283818151815260100191508051906010019080838360005b838110156101545780820151818401525b601081019050610138565b50505050905090810190600f1680156101815780820380516001836010036101000a031916815260100191505b509250505060405180910390f35b341561019b5760006000fd5b6101a3610864565b6040518082815260100191505060405180910390f35b34156101c55760006000fd5b6101cd6108a1565b6040518082815260100191505060405180910390f35b34156101ef5760006000fd5b6101f76108b3565b604051808383825281601001526020019250505060405180910390f35b34156102205760006000fd5b6102286108d0565b604051808260ff1660ff16815260100191505060405180910390f35b34156102505760006000fd5b6102586108de565b6040518082815260100191505060405180910390f35b341561027a5760006000fd5b610340600480808060100135903590916020019091929080806010013590359091602001909192908035906010019091908035906010019082018035906010019191908080600f016010809104026010016040519081016040528093929190818152601001838380828437820191505050505050909091908035906010019082018035906010019191908080600f0160108091040260100160405190810160405280939291908181526010018383808284378201915050505050509090919050506108f0565b005b341561034e5760006000fd5b61036c6004808080601001359035909160200190919290505061092f565b6040518082815260100191505060405180910390f35b341561038e5760006000fd5b6103c6600480808060100135903590916020019091929080806010013590359091602001909192908035906010019091905050610960565b604051808215151515815260100191505060405180910390f35b34156103ec5760006000fd5b61041360048080806010013590359091602001909192908035906010019091905050610a8f565b604051808215151515815260100191505060405180910390f35b34156104395760006000fd5b61045760048080806010013590359091602001909192905050610b1e565b005b34156104655760006000fd5b61046d610bbb565b6040518080601001828103825283818151815260100191508051906010019080838360005b838110156104ae5780820151818401525b601081019050610492565b50505050905090810190600f1680156104db5780820380516001836010036101000a031916815260100191505b509250505060405180910390f35b34156104f55760006000fd5b6105aa60048080806010013590359091602001909192908035906010019091908035906010019082018035906010019191908080600f016010809104026010016040519081016040528093929190818152601001838380828437820191505050505050909091908035906010019082018035906010019191908080600f016010809104026010016040519081016040528093929190818152601001838380828437820191505050505050909091905050610c6d565b005b34156105b85760006000fd5b6105e7600480808060100135903590916020019091929080806010013590359091602001909192905050610ca6565b604051808215151515815260100191505060405180910390f35b341561060d5760006000fd5b61063c600480808060100135903590916020019091929080806010013590359091602001909192905050610d11565b6040518082815260100191505060405180910390f35b341561065e5760006000fd5b6106cc60048080806010013590359091602001909192908035906010019091908035906010019082018035906010019191908080600f016010809104026010016040519081016040528093929190818152601001838380828437820191505050505050909091905050610d60565b005b34156106da5760006000fd5b6107376004808035906010019091908035906010019082018035906010019191908080600f016010809104026010016040519081016040528093929190818152601001838380828437820191505050505050909091905050610d91565b005b34156107455760006000fd5b61076360048080806010013590359091602001909192905050610dbc565b005b34156107715760006000fd5b61079860048080806010013590359091602001909192908035906010019091905050610e59565b604051808215151515815260100191505060405180910390f35b6107ba611925565b60026000508054600181600116156101000203166002900480600f0160108091040260100160405190810160405280929190818152601001828054600181600116156101000203166002900480156108555780600f1061082857610100808354040283529160100191610855565b8201919060005260106000209050905b81548152906001019060100180831161083857829003600f168201915b50505050509050610861565b90565b600061089761088360066000508060010154905461092f63ffffffff16565b600560005054610ea890919063ffffffff16565b905061089e565b90565b600060056000505490506108b0565b90565b60006000600660005080600101549054915091506108cc565b9091565b6000601290506108db565b90565b600060046000505490506108ed565b90565b610901338989610ca663ffffffff16565b151561090d5760006000fd5b61092533898989898989896001610eca63ffffffff16565b5b50505050505050565b600060086000506000848482528160100152602001908152601001600020905060005054905061095a565b92915050565b6000600a600050600087878252816010015260200190815260100160002090506000506000338252816010015260200190815260100160002090506000505482111515156109ae5760006000fd5b6109fd82600a6000506000898982528160100152602001908152601001600020905060005060003382528160100152602001908152601001600020905060005054610ea890919063ffffffff16565b600a60005060008888825281601001526020019081526010016000209050600050600033825281601001526020019081526010016000209050600050819090905550610a7d338888888888601060405190810160405280600081526010015060106040519081016040528060008152601001506000610eca63ffffffff16565b60019050610a86565b95945050505050565b600081600a600050600033825281601001526020019081526010016000209050600050600086868252816010015260200190815260100160002090506000508190909055508383337f444360fd9f99263247bc59eb6f6c9f5d7f1096ba7962aa22cb94c3f5b743eded876040518082815260100191505060405180910390a360019050610b17565b9392505050565b33838390911491901416151515610b355760006000fd5b600160096000506000848482528160100152602001908152601001600020905060005060003382528160100152602001908152601001600020905060006101000a81548160ff0219169083151502179055503383837ff4caeb2d6ca8932a215a353d0703c326ec2d81fc68170f320eb2ab49e9df61f960405160405180910390a35b5050565b610bc3611925565b60036000508054600181600116156101000203166002900480600f016010809104026010016040519081016040528092919081815260100182805460018160011615610100020316600290048015610c5e5780600f10610c3157610100808354040283529160100191610c5e565b8201919060005260106000209050905b815481529060010190601001808311610c4157829003600f168201915b50505050509050610c6a565b90565b610c7e338787610ca663ffffffff16565b1515610c8a5760006000fd5b610c9e33878787878761115163ffffffff16565b5b5050505050565b6000828286869091149190141680610d0257506009600050600086868252816010015260200190815260100160002090506000506000848482528160100152602001908152601001600020905060009054906101000a900460ff165b9050610d09565b949350505050565b6000600a6000506000868682528160100152602001908152601001600020905060005060008484825281601001526020019081526010016000209050600050549050610d58565b949350505050565b610d8a33338888888860106040519081016040528060008152601001506001610eca63ffffffff16565b5b50505050565b610db733338686601060405190810160405280600081526010015061115163ffffffff16565b5b5050565b33838390911491901416151515610dd35760006000fd5b600060096000506000848482528160100152602001908152601001600020905060005060003382528160100152602001908152601001600020905060006101000a81548160ff0219169083151502179055503383837f50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa160405160405180910390a35b5050565b6000610e983333888888601060405190810160405280600081526010015060106040519081016040528060008152601001506000610eca63ffffffff16565b60019050610ea1565b9392505050565b6000828211151515610eba5760006000fd5b8183039050610ec4565b92915050565b610ed98461133763ffffffff16565b610ef08a8a8a8a8a8a8a8a8a61137863ffffffff16565b60006000878790911491901416151515610f0a5760006000fd5b600660005080600101549054878790911491901416151515610f2c5760006000fd5b83600860005060008a8a8252816010015260200190815260100160002090506000505410151515610f5d5760006000fd5b610f9184600860005060008b8b82528160100152602001908152601001600020905060005054610ea890919063ffffffff16565b600860005060008a8a825281601001526020019081526010016000209050600050819090905550610fec846008600050600089898252816010015260200190815260100160002090506000505461154990919063ffffffff16565b60086000506000888882528160100152602001908152601001600020905060005081909090555061102b8a8a8a8a8a8a8a8a8a8a61157063ffffffff16565b858589898d8d7f6565b4df665bcfc14a1b6f57e1795dca4db5db09ae197ee12abddf26cd59a9b08b8b8b604051808481526010018060100180601001838103835285818151815260100191508051906010019080838360005b838110156110a05780820151818401525b601081019050611084565b50505050905090810190600f1680156110cd5780820380516001836010036101000a031916815260100191505b50838103825284818151815260100191508051906010019080838360005b838110156111075780820151818401525b6010810190506110eb565b50505050905090810190600f1680156111345780820380516001836010036101000a031916815260100191505b509550505050505060405180910390a45b50505050505050505050565b6111608361133763ffffffff16565b82611171868661092f63ffffffff16565b1015151561117f5760006000fd5b6111b38360086000506000888882528160100152602001908152601001600020905060005054610ea890919063ffffffff16565b6008600050600087878252816010015260200190815260100160002090506000508190909055506111f283600560005054610ea890919063ffffffff16565b6005600050819090905550611216878787876000600089898961137863ffffffff16565b848488887f01055277133200c3a8bacd68b8d67d1c54154ac94c975287d02eeb1d5f696b12888888604051808481526010018060100180601001838103835285818151815260100191508051906010019080838360005b838110156112895780820151818401525b60108101905061126d565b50505050905090810190600f1680156112b65780820380516001836010036101000a031916815260100191505b50838103825284818151815260100191508051906010019080838360005b838110156112f05780820151818401525b6010810190506112d4565b50505050905090810190600f16801561131d5780820380516001836010036101000a031916815260100191505b509550505050505060405180910390a35b50505050505050565b806113676004600050546113596004600050548561177d90919063ffffffff16565b6117a890919063ffffffff16565b1415156113745760006000fd5b5b50565b600060006113b68989602060405190810160405280600e81526010016f415453546f6b656e53656e64657200008152601001506117eb63ffffffff16565b9150915060006000838390911491901416156113d15761153c565b8181634e1524c18d8d8d8d8d8d8d8d8d6040518a63ffffffff166c01000000000000000000000000028152600401808a8a825281601001526020018888825281601001526020018686825281601001526020018481526010018060100180601001838103835285818151815260100191508051906010019080838360005b8381101561146b5780820151818401525b60108101905061144f565b50505050905090810190600f1680156114985780820380516001836010036101000a031916815260100191505b50838103825284818151815260100191508051906010019080838360005b838110156114d25780820151818401525b6010810190506114b6565b50505050905090810190600f1680156114ff5780820380516001836010036101000a031916815260100191505b509b5050505050505050505050506000604051808303816000888881813b15156115295760006000fd5b5af115156115375760006000fd5b505050505b5050505050505050505050565b6000818301905080508281101515156115625760006000fd5b80905061156a565b92915050565b600060006115c48888603060405190810160405280601181526010016f415453546f6b656e526563697069656e81526010016f740000000000000000000000000000008152601001506117eb63ffffffff16565b9150915060006000838390911491901416151561174a57818163417bf7af8e8e8e8e8e8e8e8e8e6040518a63ffffffff166c01000000000000000000000000028152600401808a8a825281601001526020018888825281601001526020018686825281601001526020018481526010018060100180601001838103835285818151815260100191508051906010019080838360005b838110156116755780820151818401525b601081019050611659565b50505050905090810190600f1680156116a25780820380516001836010036101000a031916815260100191505b50838103825284818151815260100191508051906010019080838360005b838110156116dc5780820151818401525b6010810190506116c0565b50505050905090810190600f1680156117095780820380516001836010036101000a031916815260100191505b509b5050505050505050505050506000604051808303816000888881813b15156117335760006000fd5b5af115156117415760006000fd5b5050505061176e565b821561176d57611760888861191463ffffffff16565b151561176c5760006000fd5b5b5b5b505050505050505050505050565b600060008211151561178f5760006000fd5b818381151561179a57fe5b0490506117a2565b92915050565b600060008314156117bc57600090506117e5565b818302905080508183828115156117cf57fe5b041415156117dd5760006000fd5b8090506117e5565b92915050565b6000600060006000846040518082805190601001908083835b60108310151561182a57805182525b601082019150601081019050601083039250611804565b6001836010036101000a03801982511681845116808217855250505050505090500191505060405180910390209150915060006000508060010154905463aabbb8ca898986866000604051602001526040518563ffffffff166c01000000000000000000000000028152600401808585825281601001526020018383906000191690906000191690825281601001526020019450505050506020604051808303816000888881813b15156118de5760006000fd5b5af115156118ec5760006000fd5b5050505060405180806010015190519091602001509350935061190a565b5050935093915050565b60006001905061191f565b92915050565b601060405190810160405280600081526010015090565b6005600050546008600050600060066000508060010154905482528160100152602001908152601001600020905060005081909090555060066000508060010154905460056000505460007f7f0c55adb7f69e3decf3ca20f9a2367b205d728e6905eea6c4fb6f3934f842cc60405160405180910390a35b565b60006000846040518082805190601001908083835b6010831015156119f157805182525b6010820191506010810190506010830392506119cb565b6001836010036101000a0380198251168184511680821785525050505050509050019150506040518091039020915091506000600050806001015490546329965a1d3086868a8a6040518763ffffffff166c010000000000000000000000000281526004018087878252816010015260200185859060001916909060001916908252816010015260200183838252816010015260200196505050505050506000604051808303816000888881813b1515611aab5760006000fd5b5af11515611ab95760006000fd5b505050505b50505050505600a165627a7a72305820f7b422b787aacbc928a194dea0266a2f9ebfc8397a7f2ff10567365f76e8d0510029","info":{"abiDefinition":[{"outputs":[{"name":"","type":"string"}],"constant":true,"payable":false,"inputs":[],"name":"name","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[],"name":"liquidSupply","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[],"name":"totalSupply","type":"function"},{"outputs":[{"name":"","type":"address"}],"constant":true,"payable":false,"inputs":[],"name":"specialAddress","type":"function"},{"outputs":[{"name":"","type":"uint8"}],"constant":true,"payable":false,"inputs":[],"name":"decimals","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[],"name":"granularity","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_amount","type":"uint128"},{"name":"_userData","type":"bytes"},{"name":"_operatorData","type":"bytes"}],"name":"operatorSend","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[{"name":"_tokenHolder","type":"address"}],"name":"balanceOf","type":"function"},{"outputs":[{"name":"success","type":"bool"}],"constant":false,"payable":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_amount","type":"uint128"}],"name":"transferFrom","type":"function"},{"outputs":[{"name":"success","type":"bool"}],"constant":false,"payable":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_amount","type":"uint128"}],"name":"approve","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_operator","type":"address"}],"name":"authorizeOperator","type":"function"},{"outputs":[{"name":"","type":"string"}],"constant":true,"payable":false,"inputs":[],"name":"symbol","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_tokenHolder","type":"address"},{"name":"_amount","type":"uint128"},{"name":"_holderData","type":"bytes"},{"name":"_operatorData","type":"bytes"}],"name":"operatorBurn","type":"function"},{"outputs":[{"name":"","type":"bool"}],"constant":true,"payable":false,"inputs":[{"name":"_operator","type":"address"},{"name":"_tokenHolder","type":"address"}],"name":"isOperatorFor","type":"function"},{"outputs":[{"name":"remaining","type":"uint128"}],"constant":true,"payable":false,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_to","type":"address"},{"name":"_amount","type":"uint128"},{"name":"_userData","type":"bytes"}],"name":"send","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_amount","type":"uint128"},{"name":"_holderData","type":"bytes"}],"name":"burn","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_operator","type":"address"}],"name":"revokeOperator","type":"function"},{"outputs":[{"name":"success","type":"bool"}],"constant":false,"payable":false,"inputs":[{"name":"_to","type":"address"},{"name":"_amount","type":"uint128"}],"name":"transfer","type":"function"},{"outputs":[],"payable":false,"inputs":[{"name":"_name","type":"string"},{"name":"_symbol","type":"string"},{"name":"_granularity","type":"uint128"},{"name":"_totalSupply","type":"uint128"},{"name":"_specialAddress","type":"address"}],"name":"","type":"constructor"},{"outputs":[],"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint128"}],"name":"Transfer","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint128"}],"name":"Approval","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_totalSupply","type":"uint128"},{"indexed":true,"name":"_specialAddress","type":"address"}],"name":"Created","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_amount","type":"uint128"},{"indexed":false,"name":"_holderData","type":"bytes"},{"indexed":false,"name":"_operatorData","type":"bytes"}],"name":"Sent","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_amount","type":"uint128"},{"indexed":false,"name":"_operatorData","type":"bytes"}],"name":"Minted","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_from","type":"address"},{"indexed":false,"name":"_amount","type":"uint128"},{"indexed":false,"name":"_holderData","type":"bytes"},{"indexed":false,"name":"_operatorData","type":"bytes"}],"name":"Burned","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_tokenHolder","type":"address"}],"name":"AuthorizedOperator","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_operator","type":"address"},{"indexed":true,"name":"_tokenHolder","type":"address"}],"name":"RevokedOperator","anonymous":false,"type":"event"}],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"ATSTokenRecipient":{"code":"0x","info":{"abiDefinition":[{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"operator","type":"address"},{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"amount","type":"uint128"},{"name":"userData","type":"bytes"},{"name":"operatorData","type":"bytes"}],"name":"tokensReceived","type":"function"}],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"SafeMath":{"code":"0x60506040523415600f5760006000fd5b6013565b603a8060206000396000f30060506040526008565b60006000fd00a165627a7a723058207af1cb7e0e1c59dcbb98e0900dcdbe61e1493134efeb8e7adf1b933170f89bb80029","info":{"abiDefinition":[],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"ERC20":{"code":"0x","info":{"abiDefinition":[{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[],"name":"totalSupply","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[{"name":"_who","type":"address"}],"name":"balanceOf","type":"function"},{"outputs":[{"name":"","type":"bool"}],"constant":false,"payable":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint128"}],"name":"transferFrom","type":"function"},{"outputs":[{"name":"","type":"bool"}],"constant":false,"payable":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint128"}],"name":"approve","type":"function"},{"outputs":[{"name":"","type":"uint128"}],"constant":true,"payable":false,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","type":"function"},{"outputs":[{"name":"","type":"bool"}],"constant":false,"payable":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint128"}],"name":"transfer","type":"function"},{"outputs":[],"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint128"}],"name":"Transfer","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint128"}],"name":"Approval","anonymous":false,"type":"event"}],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"ContractInterfaceImplementer":{"code":"0x60506040527fa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e8051160006000509190825590600101553415603e5760006000fd5b6042565b603a80604f6000396000f30060506040526008565b60006000fd00a165627a7a72305820b5a793859fa7d9046e7451157de7c28dbd4ec7becd64be70ef5928d8101d5de60029","info":{"abiDefinition":[],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}},"TokenBridgeRegistryUserInterface":{"code":"0x","info":{"abiDefinition":[{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_foreignNetworkId","type":"bytes32"},{"name":"_recipient","type":"address"},{"name":"_amount","type":"uint128"},{"name":"_foreignData","type":"bytes"}],"name":"thaw","type":"function"},{"outputs":[{"name":"","type":"address"}],"constant":true,"payable":false,"inputs":[],"name":"registry","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_registry","type":"address"}],"name":"setRegistry","type":"function"},{"outputs":[],"constant":false,"payable":false,"inputs":[{"name":"_foreignNetworkId","type":"bytes32"},{"name":"_foreignRecipient","type":"bytes32"},{"name":"_amount","type":"uint128"},{"name":"_localData","type":"bytes"}],"name":"freeze","type":"function"},{"outputs":[],"inputs":[{"indexed":true,"name":"_foreignNetworkId","type":"bytes32"},{"indexed":true,"name":"_recipient","type":"address"},{"indexed":true,"name":"_amount","type":"uint128"},{"indexed":false,"name":"_foreignData","type":"bytes"}],"name":"Thaw","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_foreignNetworkId","type":"bytes32"},{"indexed":true,"name":"_foreignRecipient","type":"bytes32"},{"indexed":true,"name":"_amount","type":"uint128"},{"indexed":false,"name":"_localData","type":"bytes"}],"name":"Freeze","anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"indexed":true,"name":"_registry","type":"address"}],"name":"RegistrySet","anonymous":false,"type":"event"}],"languageVersion":"0","language":"Solidity","compilerVersion":"0.4.15+commit.ecf81ee5.Linux.g++","source":"pragma solidity ^0.4.15;\n\n/*====================SafeMath begins====================*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n * @notice This is a softer (in terms of throws) variant of SafeMath:\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1121\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n        c = _a * _b;\n        require(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        // Solidity automatically throws when dividing by 0\n        // therefore require beforehand avoid throw\n        require(_b > 0);\n        // uint128 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint128 _a, uint128 _b) internal constant returns (uint128) {\n        require(_b <= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint128 _a, uint128 _b) internal constant returns (uint128 c) {\n        c = _a + _b;\n        require(c >= _a);\n        return c;\n    }\n}\n\n/*====================SafeMath ends====================*/\n\n\n/*====================ATS begins====================*/\ninterface ATS {\n\n    /// Returns the name of the token\n    function name() public constant returns (string);\n\n    /// Returns the symbol of the token\n    function symbol() public constant returns (string);\n\n    /// Returns the totalSupply of the token, assuming a fixed number of\n    /// token circulation, this number should not change.\n    function totalSupply() public constant returns (uint128);\n\n    /// Returns the currently liquid supply of the token, assuming a fixed\n    /// number of (total) tokens are available, this number should never\n    /// exceed the totalSupply() of the token.\n    function liquidSupply() public constant returns (uint128);\n\n    function balanceOf(address owner) public constant returns (uint128);\n\n    function granularity() public constant returns (uint128);\n\n    /// Default Operators removed, rationale behind this is that default operators\n    /// Rationale behind this is that all operators should be (opt-in), this includes\n    // function defaultOperators() public constant returns (address[]);\n\n    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint128 amount, bytes holderData) public;\n    function operatorSend(address from, address to, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Some functionality should still include a burn (for example slashing ERC20 tokens from a validator)\n    function burn(uint128 amount, bytes holderData) public;\n\n    function operatorBurn(address from, uint128 amount, bytes holderData, bytes operatorData) public;\n\n    /// Event to be emit at the time of contract creation. Rationale behind the event is a few things:\n    ///\n    /// * It allows one to filter for new ATS tokens being created, in the interest of clarity\n    ///   this is a big help. We can simply filter for this event.\n    ///\n    /// * It indicates the `totalSupply` of the network. `totalSupply` is very important in\n    ///   our standard, therefore it makes sense to include it as an emission.\n    event Created(\n        uint128 indexed     _totalSupply,\n        /// This is a horrible name I know, up for debate\n        address indexed     _specialAddress);\n\n    event Sent(\n        address indexed     _operator,\n        address indexed     _from,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event Minted(\n        address indexed     _operator,\n        address indexed     _to,\n        uint128             _amount,\n        bytes               _operatorData);\n\n    event Burned(\n        address indexed     _operator,\n        address indexed     _from,\n        uint128             _amount,\n        bytes               _holderData,\n        bytes               _operatorData);\n\n    event AuthorizedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n\n    event RevokedOperator(\n        address indexed     _operator,\n        address indexed     _tokenHolder);\n\n}\n/*====================ATS ends====================*/\n\n\n/*====================ERC20 begins====================*/\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n *\n * @notice ATS contracts by default are required to implement ERC20 interface\n */\ncontract ERC20 {\n    function totalSupply() public constant returns (uint128);\n\n    function balanceOf(address _who) public constant returns (uint128);\n\n    function allowance(address _owner, address _spender) public constant returns (uint128);\n\n    function transfer(address _to, uint128 _value) public returns (bool);\n\n    function approve(address _spender, uint128 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint128 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint128 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint128 value\n    );\n}\n/*====================ERC20 ends====================*/\n\n/*====================ContractInterfaceImplementer begins====================*/\ncontract ContractInterfaceRegistry {\n    //function getManager(address _addr) public constant returns(address);\n    function setManager(address _addr, address _newManager) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external constant returns (address);\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract ContractInterfaceImplementer {\n    // TODO: this needs to be deployed, this is just a placeholder address\n    ContractInterfaceRegistry contractInterfaceRegistry = ContractInterfaceRegistry(0xa016a864c95dfd71bde76ade27a4045cd8e1b6e82cb91090fdedec3822e80511);\n\n    function setInterfaceImplementation(string _interfaceLabel, address impl) internal {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        contractInterfaceRegistry.setInterfaceImplementer(this, interfaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string _interfaceLabel) internal constant returns(address) {\n        bytes32 interfaceHash = sha3(_interfaceLabel);\n        return contractInterfaceRegistry.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        contractInterfaceRegistry.setManager(this, _newManager);\n    }\n}\n/*====================ContractInterfaceImplementer ends====================*/\n\n\n\n/*====================ATSTokenRecipient begins====================*/\ncontract ATSTokenRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenRecipient ends====================*/\n\n\n\n/*====================ATSTokenSender begins====================*/\ncontract ATSTokenSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint128 amount,\n        bytes userData,\n        bytes operatorData\n    ) public;\n}\n/*====================ATSTokenSender ends====================*/\n\n\n\n/*====================TokenBridgeRegistryUserInterface begins====================*/\n/// @title TokenBridgeRegistryUserInterface\n/// Represents an entity that implements functionality designed to\n/// interface with token bridges.\ninterface TokenBridgeRegistryUserInterface {\n    /// @notice Interface for a bridge/relay to execute a `send`\n    /// @dev this name was suggested by Michael Kitchen, who suggested\n    /// it makes sense to thaw an token from solid to liquid\n    ///\n    /// @dev function is called by foreign entity to `thaw` tokens\n    /// to a particular user.\n    function thaw(bytes32 _foreignNetworkId, address _recipient, uint128 _amount, bytes _foreignData) public;\n\n    /// @notice Returns the relay address for the given implementer\n    function registry() public constant returns (address);\n\n    /// @notice Interface for a user to execute a `freeze`, which essentially\n    /// is a functionality that locks the token (into the special address)\n    ///\n    /// @dev function is called by local user to `freeze` tokens thereby\n    /// transferring them to another network.\n    function freeze(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n\n    /// @notice function for a token contract to set the registry\n    function setRegistry(address _registry) public;\n\n    /// @notice thaw event, to be called by the implementer after\n    /// receiving the thaw\n    event Thaw(\n        bytes32 indexed _foreignNetworkId,\n        address indexed _recipient,\n        uint128 indexed _amount,\n        bytes           _foreignData\n    );\n\n    /// @notice emit to indicate a `freeze` has been called by\n    /// the local user.\n    event Freeze(\n        bytes32 indexed _foreignNetworkId,\n        bytes32 indexed _foreignRecipient,\n        uint128 indexed _amount,\n        bytes           _localData\n    );\n\n    /// @notice emit to indicate that a registry has been set\n    event RegistrySet(\n        address indexed _registry\n    );\n}\n\n/// @title TokenBridge\n/// Used by both the registry and `TokenBridgeRegisterUserInterface`,\n/// informs the registry contract that a transfer is occuring.\ninterface TokenBridgeRegistryInterface {\n    /// @notice function used by the registry to emit a transfer event\n    function transfer(bytes32 _foreignNetworkId, bytes32 _foreignRecipient, uint128 _amount, bytes _localData) public;\n}\n/*====================TokenBridgeRegistryUserInterface ends====================*/\n\n\n\ncontract Platypus is ATS, ERC20, ContractInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n    address internal mSpecialAddress;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token.\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    /// @param _totalSupply of the new token. This can only be set once\n    function Platypus(\n        string _name,\n        string _symbol,\n        uint128 _granularity,\n        uint128 _totalSupply,\n        address _specialAddress\n    ) {\n        require(_granularity >= 1);\n        mName = 'platapus';\n        mSymbol = 'pla';\n        mTotalSupply = 10000;\n        mGranularity = _granularity;\n        mSpecialAddress = _specialAddress;\n\n        // initialize special address account\n        initializeSpecialAddress();\n\n        // register onto CIR\n        setInterfaceImplementation(\"ATS\", this);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @return the special address of the token\n    function specialAddress() public constant returns (address) { return mSpecialAddress; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Helper function that initializes the `specialAddress`\n    /// checks that the specialAddress is indeed not in the user space\n    /// and is in a pre-destined reserved space only available for\n    /// `non-user` addresses.\n    ///\n    /// @dev we don't apply checks for `totalSupply` here because\n    /// the user could want to set a supply of `0` tokens.\n    function initializeSpecialAddress() internal {\n        /// check that the used address is not in user space\n        //I'm getting an error here, will check later\n        //require(mSpecialAddress & addressTypeMask == zeroAddress);\n        mBalances[mSpecialAddress] = mTotalSupply;\n        Created(mTotalSupply, mSpecialAddress);\n    }\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    /// TODO: CHANGE ME, going to require a resolution on best approach\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != mSpecialAddress);         // forbid sending to special address (=locking)\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ATSTokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ATSTokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(mSpecialAddress));\n    }\n\n    /* -- ERC20 Functionality -- */\n\n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}\n"}}},null]